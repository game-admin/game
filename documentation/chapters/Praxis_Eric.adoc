== Praktische Aufgabenstellung: Eric Haneder

== Front End: Design und Graphic User Interface

=== Beginning
To start with designing user interfaces (= front end), a design must be agreed with the client which suits the client an is realizable for us. The front end is the most important part for the user, because it includes everything the user can see and interact with. I discussed this topic with the client and we came to a conclusion

Here is an abstract picture, how the user interfaces should look like:

.User interfaces
image::../img/UserInterfaces.png[]

After the design was agreed upon, the programming of the interfaces could begin.

=== Fundamentals
Um eine Website zu programmieren, benötigt man ein Menge an umfangreichen Wissen. Man muss html, javascript und css beherrschen. Darüber hinaus sollte man auch wissen, wie aus dem Code eine fertige Seite erzeugt wird, und wie Requests vom User ausgewertet und darauf geantwortet werden kann.
To program a website, you need a lot of extensive knowledge. You have to know HTML, Javascript and CSS. In addition, you should also know how a finished page is generated from the code you programmed and how requests from the user can be evaluated and responded to.

==== JSF
Java Server Faces (JSF) is a programming framwork for the development of graphical user interfaces (GUIs). JSF is a part of the web-technologies of _Java Enterprise Edition_ (Java EE). 
The following graphic shows the architecture of JSF:

.JSF architecture
image::../img/Architektur.png[]

 * The Browser is there, to display the websites to the user. Through the browser, users can navigate through the interfaces, make requests to the server and get a respone back.
* The Faces Servlet handles user interactions that may lead to changes in the data structure (back en) or on the user interfaces (front end). It can be seen as a controller between the front end and the back end. Every request runs through the Faces Servlet which takes action accordingly. It can optionally be configured by a _faces-config.xml_ file.
* The Renderers are responsible for displaying a component an translating a user's input into the component property values.
* Converters convert a component's value (Integer, Boolean, etc.) to and from markup values (String).
* Validators are responsible for ensuring that the value entered by a user is valid.
* The business logic is made in backing beans, which also control the navigation between pages.
* Facelets describes the language in which JSF files are written (XHTML). Every page has certain components which will be displayed by the browser with the help of renderers.





_(vgl. Goncalves A. (2013). Beginning Java EE 7. Apress.)_


==== HTML
Hypertext Markup Language (HTML) is the common used language for building web pages. A HTML page is a text document (with a .html or .htm extension) used by browsers to present text and graphics. A web page is made of content, tags to change some aspects of the content, and external objects such as images, videos, JavaScript, or CSS files.

.Sample code for a HTML page
[source, html]
----
<html>
    <head>
        <title>My Webpage</title>
    </head>
    <body>
        <h1>This is my webpage</h1>
        <p>
            I hope you like it.
        </p>
        <a href="www.google.at">Link to Google</a>
    </body>
</html>
----
NOTE: U can notice several tags in this code (such as <body> or <p>). Every tag has its on purpose, attributes and must be closed. Href is an attribute of the a-tag.

XHTML is just a validated version of html. This means, that there are certain rules, a html-page has to follow, to be valid. XHMTL pages have a .xhtml extension.

Some of the rules are the following:

* All tags must be closed. (so no <br>, <hr>, ...)
* All tags are lowercase.
* Attributes appear appear between single or double quotes (<table border="0"> instead of <table border = 0>)
* There must be a strict structure with <html>, <head> and <body> tags.

==== CSS
Cascading Style Sheets (CSS) is a styling language used to describe the presentation of a document written in html or xhtml. CSS is used to define colors, fonts layouts, and other aspects of document presentation.It allows separation of a document’s content (written in XHTML) from its presentation (written in CSS).
To embedd a .css file in your html or xhtml page, use the <link> tag.
(e.g. <link rel="stylesheet" type="text/css" ?

.Your css file could look like this:
[source,css]
----
p {
    font-size: 10px;
}
h1 {
    color: red;
    font-style: italic;
}
----


=== Getting Started
==== Creating a project structure
To start with a project like this, you need a clean project structure. The project structure has been automatically created with Maven. Our project is "Open Source", that means it is available online for free. That includes our whole project structure and all of the files used to create the website.
The complete GAME project can be viewed under: https://github.com/game-admin/game

==== Creating a layout
To simplify the creation of the UIs, I prepared a layout which serves every page as a template. This layout is realised in "mainlyaout.xhtml". It constructs the picture at the the top of every file with the headline, the menubar and a little picture in the footer.

image:../img/layout1.png[]

This page is not displayed directly to the user, but rather represents a template for all user interfaces. Other pages can define this page as a template and then adopt its content. By using <ui:insert> in the template file, you can give the template clients the possibility to define the content of this tag themselves with <ui:define>. This is shown in any of the actual user interfaces.

The menubar is constructed on another file called "menubar.xhtml". It is used to navigate through the platform. Furthermore, the menubar file is very unique, because it is not used directly in every file, but is displayed on every page. This is due to all of the pages using the mainlayout file as a template. It is include in the mainlayout file with the <ui:include> tag:

[source,html]
----
<ui:include src="./faces/menubar.xhtml"></ui:include>
----

The menubar is created by usind the <p:tabMenu> tag of the Primefaces library. It is very convenient to create a menubar with this tag.

.menubar.xhtml
[source,html]
----
include::../game-trainee-web/src/main/webapp/faces/menubar.xhtml[tag=menubar]
----

The "Logout" button on the far left is done with the <p:splitButton> tag. It is placed in the menubar with CSS.

[source, html]
----
include::../game-trainee-web/src/main/webapp/faces/menubar.xhtml[tag=splitButton]
----

I had to separate the menubar from the mainlyout, because of interferences with the formulars.

=== User-Interfaces
Die UIs liegen hier unter src\main\webapp\faces. "ev. noch was zu UIs sagen"

The index-page is the standard page the browser will run, if you enter a website. On this page, the user should get an overwiev about his statistics, and he should be able to navigate to other pages.
The structure of the index-page is pretty simple. All data of the current user is fetched from the database and displayed. The trainee can look at his nickname, score, progress and emblems. Furthermore, a little description of the GAME-site is displayed. From here on, the trainee can check out some courses, take quizzes, look at trainers or visit the emblemboard.

The data is displayed via expression langugage. Here is an example:

[source,html]
----
#{traineeController.getTraineesByID("1").get(0).nickname} 
----


==== Courses-page

The Courses-page should display a list of courses the trainee can go through. These courses can be mandatory to complete Quizzes.

.courses.xhtml
[source,html]
----
include::../game-trainee-web/src/main/webapp/faces/courses.xhtml[tag=dataTable]   
----
<1> The Primefaces tag <p:dataTable> takes a list and knows how to display its content throught the columns. It is the equivalent to the <table> tag of html, but with some extra functions and style modifications. Here, I put in a list of courses. Every course in the list has a titel, description and a link which is displayed in separated columns.

The <p:commanButton> invokes the takeKurs-method when pressed. In this method, a link of the selected course is returned.
The <h:commandLink> is linked to the URL of the course. By clicking on it, the user is redirected to the site of the course.

This is how the courses interface looks like:

image::../img/kurs1.png[]

==== Quiz pages
The quiz pages include a interface, where every takeable quiz is displayed, two pages for taking a quiz and a page where the results are shown. Every quiz has its own emblem, which can be won if they quiz is taken succesfully. This means the user has to has at least half of the questions right.

.quizzes.xhtml
[source,html]
----
include::../game-trainee-web/src/main/webapp/faces/quizzes.xhtml[tag=dataTable]
----
Here, <p:dataTable> is used again, this time to show all available quizzes. It gets a list of quizzes and displays a quiz whether or not it is takeable. This is evaluated in the isTakeable-method in the QuizController Bean.

This is how it looks like, when the user has not fulfilled the requirements to take a quiz:

image::../img/quiz1.png[]

In this picture below, the trainee has met all the requirements needed for the second quiz. To take the second quiz, the user must succesfully take the first quiz.

image::../img/quiz2.png[]

By clicking on the <p:commandButton>, the user can take the quiz.

.takequiz.xhtml
[source,html]
----
include::../game-trainee-web/src/main/webapp/faces/takequiz.xhtml[tag=repeat]
----
This is the page for taking singlechoice-quizzes. The questions are repeatadly displayed by the <ui:repeat> tag. This tag runs through a given list, and displays the wanted data. The answers are displayed with the <p:selectOneRadio>, which renderes a set of buttons based on the data you set with <f:selectItem>.

image::../img/takequiz1.png[]
image::../img/takequiz2.png[]

By clicking on the "Check Answers" button, the trainee is redirected to the results page.

The page for taking multiplechoice quizzes looks almost the same, except for the buttons. I used <p:selectBooleanCheckbox> tags here, because they can be used for multiplechoice purposes. Each of these buttons must be bound to a Boolean property.

"Bilder für takeQuizMultipleChoice"

The results page is responsible for displaying the results of the quiz taken by the trainee. The trainee is able to see how many questions he/she answered right, how many points he/she won and which questions he/she answered incorrectly. Furthermore, the user sees which answers is right for every question. If the question is green and checked, the user answered correctly. If the question is red with a X at the end, the user answered incorrectly.

image::../img/results.png[]

==== Trainer page
The Trainers page should display all the trainers associated with the GAME platform. The trainees can contact these trainers if they need help.

.trainers.xhtml
[source,html]
----
include::../game-trainee-web/src/main/webapp/faces/trainers.xhtml[tag=trainer]
----
Here I used a primefaces tag called <p:carousel>. This tag is used to create a carousel. The <p:panelGrid> tag is used to display data in a grid. The <p:graphicImage> is just like the JSF tag <h:graphicImage>. <h:outputText> is used to display text, with the function to call a Backing Bean. For easier explanation here is a picture:

image::../img/trainers.png[]
 
==== Emblemboard
The emblemboard page is used to diplay all the trainees with their names, nicknames, branches and Icons they got. You should be able to sort them by their names.
 
.leaderboard.xhtml
[source,html]
----
include::../game-trainee-web/src/main/webapp/faces/leaderboard.xhtml[tag=dataTable]
----

Here, the <p:dataTable> tag is used once again. This time it display all the trainees with their emblems for the other trainees to see. Users can compare each other and are able to check out how the other users are doing.

image::../img/emblemtafel.png[]

=== Java classes
Java Classes contain business logic that are need for the application. For example, if you want to display data on a page, you have to fetch data. This is done with Java files. To be more specific, Java classes which communicate with pages are called _Backing Beans_.  

==== Trainer Classes

.TrainerController.java
[source,java]
----
@Named
@ViewScoped
public class TrainerController implements Serializable {
     
    private List<Trainer> trainers;
     
    private Trainer selectedTrainer;
     
    @Inject
    private TrainerService service;
     
    @PostConstruct
    public void init() {
        trainers = service.createTrainers(6);
    }
 
    //Getters & Setters
}

----

The TrainerController-Class is used to diplay all the trainers on the trainers.xhtml page.

.TrainerService.java
[source,java]
----
@Named
@ApplicationScoped
public class TrainerService {
     
    private final static String[] roles; 
    private final static String[] branches;
    private final static String[] names;
     
    static {
        roles = new String[4];
        roles[0] = "Abteilungsleiter";
        roles[1] = "Gruppenleiter";
        roles[2] = "Projektleiter";
        roles[3] = "Projektmitglied";
         
        branches = new String[3];
        branches[0] = "Development";
        branches[1] = "Architecture";
        branches[2] = "Design";
        
        names = new String[10];
        names[0] = "Max";
        names[1] = "Peter";
        names[2] = "Tim";
        names[3] = "Tom";
        names[4] = "Alex";
        names[5] = "Josef";
        names[6] = "Tobias";
        names[7] = "Benji";
        names[8] = "Michael";
        names[9] = "Martin";
      
    }
     
    public List<Trainer> createTrainers(int size) {
        List<Trainer> list = new ArrayList<>();
        for(int i = 0 ; i < size ; i++) {
            list.add(new Trainer(getRandomName(), getRandomBranch(), getRandomRole()));
        }
        return list;
    }
     
    //Getters
}
----

The TrainerService class is used to create dummy data, that can be displayed on the trainers page.

==== Trainee Classes

.TraineeController.java
[source,java]
----
@Named
@ViewScoped
public class TraineeController implements Serializable {
    private List<Trainee> trainees;
    private Trainee selectedTrainee;
    
    @Inject
    private TraineeEJB traineebean;
    

    public List<Trainee> getTraineesByID(String mitid) {
        List<Trainee> list = new ArrayList<>(1);
        Trainee trainee = traineebean.find(mitid);
        list.add(trainee);
        return list;
    }
    
    //Getters & Setters
}

----
The TraineeController-Class is used to display all trainees on the leaderboard-page.

==== Quiz Classes

.QuizController
[source,java]
----
@Named
@SessionScoped
public class QuizController implements Serializable {
     
    private List<Quiz> quizzes;
    private List<Results> results;
    private int score;
    private Trainee trainee;
    private int ricounter;
    private String emblem = "javapro.png";
    private List<FrageModell> fragemodell;
    private String qid;
    
    @Inject 
    private ModellCreator creator;
    @Inject
    private TraineeEJB traineebean;
    @Inject
    private FrageEJB fragebean;
    @Inject
    private QuizEJB quizbean; <1>
    @Inject
    private QuizbeantwortungEJB quizbeantw;
    @Inject
    private QuizVoraussetzungEJB quizvoraussetzung;
    @Inject
    private VoraussetzungEJB voraussetzungejb;

    @PostConstruct <2>
    public void init() {
        fragemodell = creator.createModell(qid);
        results = new ArrayList<>();
        ricounter = 0;
    }
    
    public String checkAnswersSingleChoice() {
        FacesContext fc = FacesContext.getCurrentInstance();
        Map<String,String> params = fc.getExternalContext().getRequestParameterMap();
        String varqid = params.get("qid");
        this.qid = varqid;
        evaluateScoreRadio();
        return "result.xhtml";
    }
    
    public String checkAnswersMultipleChoice() {
        FacesContext fc = FacesContext.getCurrentInstance();
        Map<String,String> params = fc.getExternalContext().getRequestParameterMap();
        String varqid = params.get("qid");
        this.qid = varqid;
        evaluateScoreMultiple();
        return "result.xhtml";
    }
    
    public void evaluateScoreMultiple() { <3>
        List<Integer> falsche = new ArrayList<>();
        int richtige=0;  
        for(int i=0; i<fragemodell.size(); i++ ) {
            List<Integer> indexrichtig = umwandler(fragemodell.get(i).indexrichtig);
            for(int z=0; z<4; z++) {
                if(indexrichtig.get(z) == 1 && !fragemodell.get(i).buttons[z] || indexrichtig.get(z) == 0 && fragemodell.get(i).buttons[z]) {
                    falsche.add(i);
                    z=999;
                } else {
                    richtige++;
                }
            }
            if(richtige==4) {
                score+=10;
                ricounter++;
                falsche.add(9999);
            }
            richtige = 0;
        } 
        checkResults(falsche); 
    } 
    
    public void evaluateScoreRadio() { <4>
        List<Integer> falsche = new ArrayList<>();
        for(int i=0; i<fragemodell.size(); i++) {
            if(fragemodell.get(i).selectedAnswer.equals(fragemodell.get(i).antworten.get(fragemodell.get(i).indexrichtig))) {
                score+=10;
                ricounter++;
                falsche.add(9999);
            } else {
                falsche.add(i);
            }
        }
        checkResults(falsche); 
    }
    
    public String quizUebergabe(String qid) {
        this.qid = qid;
        fragemodell = creator.createModell(qid);
        ricounter = 0;
        score=0;
        if(quizbean.find(qid).getMultiplechoice()) {
            return "takeQuizMultipleChoice.xhtml";
        } else {
            return "takequiz.xhtml"; 
        }
    }
    
    public List<Integer> umwandler(int indexrichtig) {
        List<Integer> liste = new ArrayList<>();
        for(int i=0; i<4; i++)
            if(indexrichtig==i) {
                liste.add(1);
            } else {
                liste.add(0);
            }
        return liste;
    }
    public int makeListToIndexRichtig(List<Antwortmoeglichkeiten> antworten) { //Used here?
        for (int i = 0; i < 4; i++) {
            if(antworten.get(i).isRichtigeAntwort()) {
                return i;
            }
        }  
        return 0;
    }
    
    public void checkResults(List<Integer> falsche) {
        results = new ArrayList<>();
        for(int i=0; i<fragemodell.size(); i++) {
            List<Integer> indexrichtig = umwandler(fragemodell.get(i).indexrichtig);
            if(falsche.get(i) == i) {
                results.add(new Results(fragemodell.get(i).frage, fragemodell.get(i).antworten, indexrichtig, true));
            } else {
                results.add(new Results(fragemodell.get(i).frage, fragemodell.get(i).antworten, indexrichtig, false));
            }
        }
     trainee = traineebean.find("1");
     trainee.setProgress(trainee.getProgress()+score);
     traineebean.update(trainee);
     List<Quizbeantwortung> list =  quizbeantw.findByQIDAndMITID(qid, "1");
     list.get(0).setErreichtePunkte(score);
     if(score > fragemodell.size()*10/2) {
        list.get(0).setIstbestanden(true);
     }
     quizbeantw.update(list.get(0));
    }
    
    public Boolean isTakeable(String qid, String mitid) {
        List<QuizVoraussetzung> quizvor = quizvoraussetzung.findAllQuizVoraussetzzungen(qid);
        if(quizvor.isEmpty()) {
            return TRUE;
        }
        Voraussetzung vor = voraussetzungejb.find(quizvor.get(0).getQuizVorraussetzID());
        String id = vor.getQuiz().getQID();
        List<Quizbeantwortung> list = quizbeantw.findByQIDAndMITID(id, mitid);
        if(list.get(0).isIstbestanden()) {
            return TRUE;
        }
        
        return FALSE;
    }

    //Getters & Setters
}
----
<1> Here, the QuizEJB is injected via the Jave EE Dependy Injection System. This way, we can use everything from the injected Class, without the need of calling a contructor.
<2> The annotation _PostContruct_ functions as a note to the container, that this method must be run, before the construction of the Class.
<3> This method is used to evaluate the results of a MultipleChoice-Quiz. Each button is bound to a boolean-wert of the buttons[]. Every Question is checked, if every button matches the right answers. The user only gets points, if he answers the question correctly. 
<4> Here, the singlechoice-quizzes get evaluated. This is much easier, because the radiobuttons function differently than the normal buttons. Every set of radiobuttons is bound to one value (selectedAnswer). We only need to check if the selected Answer matches the correct Answer. 
<5>
In _checkResults_, a _Results-List_ i s generated. This list is used to diplay the results on the results.xhtml page.

The QuizController is used to handle everything surrounding the action of taking a quiz. It is responsible for displaying the content on the quizzes-, takequiz- and results-page. It will forward the user from the quizzes page to the takequizpage, where he/she can take the quiz. By clicking on th Submit button, the user is forwarded to the results-site, where their results are shown. 

=== Summary/Conclusion
"was ghört hir hin?"




